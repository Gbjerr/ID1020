/**
 *
 * Assignment 6 for lab 2
 *
 * Following program tests and measures the execution times for sorting algorithm
 * merge sort where insertion sort will handle sub-arrays for a cutoff values in
 * the range ~[0, 30]. The size of the array to be sorted, is N, which is given as
 * argument. Arrays are generated by different seeds which is used for creating
 * a "random" sequence of integers for the arrays to be sorted.
 *
 */

import java.util.Random;

public class L2Assignment6 {
    private final static int K = 1000000;
    private static final int[] cutOffs = {5, 10, 15, 20, 25, 30};

    private static int N;
    private static int cutOff;


    public static void main(String[] args) {

        // interrupt if arguments was not entered correctly
        if(args.length != 1) {
            System.out.println("ERROR: Arguments <N> was not entered.");
            System.exit(1);
        }

        N = Integer.parseInt(args[0]);

        // interrupt if size of array, was less or equal to size 1
        if(N <= 1) {
            System.out.println("ERROR: Argument <N> must be greater than 1.");
            System.exit(1);
        }


        runAlgorithms();

    }

    /**
     * Method takes an argument long as seed for Random function which generates
     * different values of integers and puts them to array and returns that array
     */
    private static int[] generateArray(long seed) {
        int val;
        int[] arr = new int[N];
        Random generator = new Random(seed);

        for(int i = 0; i < N; i++) {
            val = generator.nextInt(K);

            arr[i] = val;
        }
        return arr;
    }


    /**
     * Method that runs and measures execution times for sorting merge with cutoff
     */
    private static void runAlgorithms() {
        int[] arr;

        // seed generated by function currentTimeMillis
        long seed = System.currentTimeMillis();
        long start, end;

        for(int i = 0; i < cutOffs.length; i++) {
            cutOff = cutOffs[i];

            // generate an array and measure time for sorting it
            arr = generateArray(seed);
            start = System.nanoTime();
            arr = mergeSort(arr);
            end = System.nanoTime();
            double time = (((double) (end - start)) * (Math.pow(10, -9)));
            assert isSorted(arr);


            System.out.printf("\nTime taken for merge sort to sort %d elements with cutoff %d took %f seconds", N, cutOff, time);
        }

    }

    /**
     * Method which sorts and returns an array of integers using algorithm Merge sort.
     * @param arr - The array to be sorted.
     * @return the sorted array
     */
    private static int[] mergeSort(int[] arr) {

        // if array size is 1 just return, otherwise let insertion handle cutoff
        // sizes
        if(arr.length == 1) {
          return arr;
        }
        else if(arr.length <= cutOff) {
            return insertionSort(arr);
        }


        int mid = arr.length / 2;


        int[] left = new int[mid];
        // if input array has un-even length assert the un-even part to second sub array
        int[] right = arr.length % 2 == 0 ? new int[mid] : new int[mid + 1];

        // copy elements from input array to left and right sub array
        for(int i = 0; i < arr.length ; i++) {
            if(i <= mid-1) {
                left[i] = arr[i];
            } else {
                right[i - mid] = arr[i];
            }
        }

        // continue to divide left and right sub array until all sub arrays has one element
        left = mergeSort(left);
        right = mergeSort(right);

        // merge arrays
        return merge(left, right);

    }

    /**
     * Method merges two sub-arrays .
     * @param left - left sub-array
     * @param right - right sub-array
     * @return the resulting merged array
     */
    private static int[] merge(int[] left, int[] right) {
        int leftPoint, rightPoint, resPoint;
        leftPoint = rightPoint = resPoint = 0;
        int[] res = new int[left.length + right.length];

        //if there is elements in either the left, or the right array
        while(leftPoint < left.length || rightPoint < right.length){

            //if there exists elements in both arrays
            if(leftPoint < left.length && rightPoint < right.length) {


                //depending on which element that is greater, assert
                //the minor one to the resulting array and increment by 1
                if(left[leftPoint] < right[rightPoint]) {
                    res[resPoint++] = left[leftPoint++];
                } else {
                    res[resPoint++] = right[rightPoint++];
                }
            }
            else if(leftPoint < left.length) {
                res[resPoint++] = left[leftPoint++];
            }
            else if(rightPoint < right.length) {
                res[resPoint++] = right[rightPoint++];
            }

        }
        return res;
    }


    /**
     * Method which sorts an array of integers using algorithm Insertion sort.
     * @param arr - The array to be sorted.
     */
    public static int[] insertionSort(int[] arr) {

        int var;
        // iterates array through from second element of the array
        for (int i = 1; i < arr.length; i++) {

            // swap adjacent elements at position j and j-1 until element at position
            // j is greater than element at position j-1
            for (int j = i; j > 0 && (arr[j-1] > arr[j]); j--) {
                // swap adjacent elements
                var = arr[j-1];
                arr[j-1] = arr[j];
                arr[j] = var;

            }
        }
        return arr;
    }

    /**
     * Method checks if an array of integers is sorted
     * @param arr - the array to check if sorted
     * @return boolean condition whether the array is sorted or not
     */
    private static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++)
            if (arr[i - 1] > arr[i]) {
                return false;
            }
        return true;
    }
}
