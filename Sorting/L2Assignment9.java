/**
 *
 * Assignment 8 for lab 2
 *
 * Following program tests and measures the execution times for sorting algorithms
 * normal quick sort and quick sort with MOT implementation for large input sizes N.
 * Arrays are generated with the help of different seeds which is used for creating
 * a "random" sequence of integers for the arrays to be sorted.
 */

import java.util.Random;
import java.lang.Math;

public class L2Assignment9 {
    private static int K = 1000000;
    private static int N;


    public static void main(String[] args) {

        System.out.println("******* Assignment 8 *******\n");

        if(args.length != 1) {
          System.out.println("Arguments <N> was not entered.");
          System.exit(1);
        }

        N = Integer.parseInt(args[0]);

        if(N <= 1) {
          System.out.println("Argument <N> must be greater than 1.");
          System.exit(1);
        }


        runAlgorithms();

    }

    // method takes an argument long as seed for Random function which generates different
    // values of ints and puts them to array and returns that array
    private static int[] generateArray(long seed) {
        int val;
        int[] arr = new int[N];
        Random generator = new Random(seed);

        for(int i = 0; i < N; i++) {
            val = Math.abs(generator.nextInt(K) + 1);

            arr[i] = val;
        }
        return arr;
    }


    // method that runs and measures execution times for sorting merge and insertion sort
    // for 14 different sizes of arrays generated by different seeds
    private static void runAlgorithms() {
        int[] arr;

        // seed generated by function currentTimeMillis
        long seed = System.currentTimeMillis();
        long start, end;

        //test for merge sort
        arr = generateArray(seed);
        start = System.nanoTime();
        quickSort(arr, 0, arr.length - 1);
        end = System.nanoTime();
        double time1 = (((double) (end - start)) * (Math.pow(10, -9)));
        assert isSorted(arr);


        //test for quick sort
        arr = generateArray(seed);
        start = System.nanoTime();
        quickSortMOT(arr, 0, arr.length - 1);
        end = System.nanoTime();
        double time2 = (((double) (end - start)) * (Math.pow(10, -9)));
        assert isSorted(arr);

        System.out.printf("\nTime taken for normal quick sort to sort %d elements took %f seconds", N, time1);
        System.out.printf("\nTime taken for MOT quick sort to sort %d elements took %f seconds", N, time2);


    }

    private static void quickSort(int[] a, int lo, int hi) {
        if((a.length > 1) && (lo < hi)) {

            int position = partition(a, lo, hi);

            quickSort(a, lo, position - 1);
            quickSort(a, position + 1, hi);
        }

    }

    // partitions sub array left <----> right so that element the last element in
    // the array is at a position where elements right of it is greater and elements at left
    private static int partition(int[] a, int lo, int hi) {

        int pivotVal = a[hi];
        int i = lo - 1;

        for(int j = lo; j < hi; j++) {
            if(a[j] < pivotVal) {
                i++;

                swap(a, i, j);
            }
        }

        int p = a[i + 1];
        a[i + 1] = a[hi];
        a[hi] = p;

        return i + 1;
    }

    private static void quickSortMOT(int[] a, int lo, int hi) {
        if((a.length > 1) && (lo < hi)) {

            int position = partition(a, lo, hi);

            quickSort(a, lo, position - 1);
            quickSort(a, position + 1, hi);
        }

    }

    // partitions sub array left <----> right so that element the last element in
    // the array is at a position where elements right of it is greater and elements at left
    private static int partitionMOT(int[] a, int lo, int hi) {

        int pivotVal = medianOfThree(a, lo, hi);
        int i = lo - 1;

        for(int j = lo; j < hi; j++) {
            if(a[j] < pivotVal) {
                i++;

                swap(a, i, j);
            }
        }

        int p = a[i + 1];
        a[i + 1] = a[hi];
        a[hi] = p;

        return i + 1;
    }

    public static int medianOfThree(int[] arr, int l, int r) {
        int mid = (l + r) / 2;

        if (arr[l] > arr[mid])
            swap(arr, l, mid);

        if (arr[l] > arr[r])
            swap(arr, l, r);

        if (arr[mid] > arr[r])
            swap(arr, mid, r);

        swap(arr, mid, r - 1);
        return arr[r - 1];
    }

    public static void swap(int[] arr, int i1, int i2) {
        int temp = arr[i1];
        arr[i1] = arr[i2];
        arr[i2] = temp;
    }

    private static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++)
            if (arr[i - 1] > arr[i]) {
                return false;
            }
        return true;
    }

}
