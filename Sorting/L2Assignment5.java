/**
 *
 * Assignment 5 for lab 2
 *
 * Following program tests and measures the execution times for sorting algorithms
 * insertion sort and merge sort for input size N. Arrays are generated by different
 * seeds which is used for creating a "random" sequence of integers for the arrays
 * to be sorted.
 */

import java.util.Random;

public class L2Assignment5 {
  private final static int K = 1000000;

  private static int N;

    public static void main(String[] args) {

      // interrupt if arguments was not entered correctly
      if(args.length != 1) {
        System.out.println("ERROR: Argument <N> was not entered.");
        System.exit(1);
      }

      N = Integer.parseInt(args[0]);

      // interrupt if size of array, was less or equal to size 1
      if(N <= 1) {
        System.out.println("ERROR: Argument <N> must be greater than 1.");
        System.exit(1);
      }

      runAlgorithms();

    }

    /**
     * Method takes an argument long as seed for Random function which generates
     * different values of integers and puts them to array and returns that array
     */
    private static int[] generateArray(long seed) {
        int val;
        int[] arr = new int[N];
        Random generator = new Random(seed);

        for(int i = 0; i < N; i++) {
            val = generator.nextInt(K);

            arr[i] = val;
        }
        return arr;
    }


    /**
     * Method that runs and measures execution times for sorting algorithm merge
     * and insertion sort, of arrays generated by different seeds.
     */
    private static void runAlgorithms() {
        int[] arr;

        // seed generated by function currentTimeMillis
        long seed = System.currentTimeMillis();
        long start, end;

        //test for merge sort
        arr = generateArray(seed);
        start = System.nanoTime();
        arr = mergeSort(arr);
        end = System.nanoTime();
        double time1 = (((double) (end - start)) * (Math.pow(10, -9)));
        assert isSorted(arr);


        //test for insertionsort
        arr = generateArray(seed);
        start = System.nanoTime();
        insertionSort(arr);
        end = System.nanoTime();
        double time2 = (((double) (end - start)) * (Math.pow(10, -9)));
        assert isSorted(arr);

        System.out.printf("\nTime taken for merge sort to sort %d elements took %f seconds", N, time1);
        System.out.printf("\nTime taken for insertion sort to sort %d elements took %f seconds", N, time2);


    }


    /**
     * Method which sorts and returns an array of integers using algorithm Merge sort.
     * @param arr - The array to be sorted.
     * @return the sorted array
     */
    private static int[] mergeSort(int[] arr) {
        // return if array only has one element
        if(arr.length <= 1) {
            return arr;
        }

        int mid = arr.length / 2;


        int[] left = new int[mid];
        // if input array has un-even length assert the un-even part to second sub array
        int[] right = arr.length % 2 == 0 ? new int[mid] : new int[mid + 1];

        // copy elements from input array to left and right sub array
        for(int i = 0; i < arr.length ; i++) {
            if(i <= mid-1) {
                left[i] = arr[i];
            } else {
                right[i - mid] = arr[i];
            }
        }

        // continue to divide left and right sub array until all sub arrays has one element
        left = mergeSort(left);
        right = mergeSort(right);

        // merge arrays
        return merge(left, right);

    }

    /**
     * Method merges two sub-arrays .
     * @param left - left sub-array
     * @param right - right sub-array
     * @return the resulting merged array
     */
    private static int[] merge(int[] left, int[] right) {
        int leftPoint, rightPoint, resPoint;
        leftPoint = rightPoint = resPoint = 0;
        int[] res = new int[left.length + right.length];

        //if there is elements in either the left, or the right array
        while(leftPoint < left.length || rightPoint < right.length){

            //if there exists elements in both arrays
            if(leftPoint < left.length && rightPoint < right.length) {


                //depending on which element that is greater, assert
                //the minor one to the resulting array and increment by 1
                if(left[leftPoint] < right[rightPoint]) {
                    res[resPoint++] = left[leftPoint++];
                } else {
                    res[resPoint++] = right[rightPoint++];
                }
            }
            else if(leftPoint < left.length) {
                res[resPoint++] = left[leftPoint++];
            }
            else if(rightPoint < right.length) {
                res[resPoint++] = right[rightPoint++];
            }

        }
        return res;
    }


    /**
     * Method which sorts an array of integers using algorithm Insertion sort.
     * @param arr - The array to be sorted.
     */
    public static void insertionSort(int[] arr) {

        int var;
        // iterates array through from second element of the array
        for (int i = 1; i < arr.length; i++) {

            // swap adjacent elements at position j and j-1 until element at position
            // j is greater than element at position j-1
            for (int j = i; j > 0 && (arr[j-1] > arr[j]); j--) {
                // swap adjacent elements
                var = arr[j-1];
                arr[j-1] = arr[j];
                arr[j] = var;

            }
        }
    }

    /**
     * Method checks if an array of integers is sorted
     * @param arr - the array to check if sorted
     * @return boolean condition whether the array is sorted or not
     */
    private static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++)
            if (arr[i - 1] > arr[i]) {
                return false;
            }
        return true;
    }


}
