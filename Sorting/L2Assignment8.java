/**
 *
 * Assignment 8 for lab 2
 *
 * Following program tests and measures the execution times for sorting algorithms
 * quick sort and merge sort for array with large input sizes N. Arrays are generated with the
 * help of different seeds which is used for creating a "random" sequence of integers
 * for the arrays to be sorted.
 */

import java.util.Random;
import java.lang.Math;

public class L2Assignment8 {
    private static int K = 1000000;
    private static int N;


    public static void main(String[] args) {

        System.out.println("******* Assignment 8 *******\n");

        if(args.length != 1) {
          System.out.println("Arguments <N> was not entered.");
          System.exit(1);
        }

        N = Integer.parseInt(args[0]);

        if(N <= 1) {
          System.out.println("Argument <N> must be greater than 1.");
          System.exit(1);
        }


        runAlgorithms();

    }

    // method takes an argument long as seed for Random function which generates different
    // values of ints and puts them to array and returns that array
    private static int[] generateArray(long seed) {
        int val;
        int[] arr = new int[N];
        Random generator = new Random(seed);

        for(int i = 0; i < N; i++) {
            val = Math.abs(generator.nextInt(K) + 1);

            arr[i] = val;
        }
        return arr;
    }


    // method that runs and measures execution times for sorting merge and insertion sort
    // for 14 different sizes of arrays generated by different seeds
    private static void runAlgorithms() {
        int[] arr;

        // seed generated by function currentTimeMillis
        long seed = System.currentTimeMillis();
        long start, end;

        //test for merge sort
        arr = generateArray(seed);
        start = System.nanoTime();
        arr = mergeSort(arr);
        end = System.nanoTime();
        double time1 = (((double) (end - start)) * (Math.pow(10, -9)));
        assert isSorted(arr);


        //test for quick sort
        arr = generateArray(seed);
        start = System.nanoTime();
        quickSort(arr, 0, arr.length - 1);
        end = System.nanoTime();
        double time2 = (((double) (end - start)) * (Math.pow(10, -9)));
        assert isSorted(arr);

        System.out.printf("\nTime taken for merge sort to sort %d elements took %f seconds", N, time1);
        System.out.printf("\nTime taken for quick sort to sort %d elements took %f seconds", N, time2);


    }


    private static int[] mergeSort(int[] arr) {
        // return if array only has one element
        if(arr.length <= 1) {
            return arr;
        }

        int mid = arr.length / 2;


        int[] left = new int[mid];
        // if input array has un-even length assert the un-even part to second sub array
        int[] right = arr.length % 2 == 0 ? new int[mid] : new int[mid + 1];

        // copy elements from input array to left and right sub array
        for(int i = 0; i < arr.length ; i++) {
            if(i <= mid-1) {
                left[i] = arr[i];
            } else {
                right[i - mid] = arr[i];
            }
        }

        // continue to divide left and right sub array until all sub arrays has one element
        left = mergeSort(left);
        right = mergeSort(right);

        // merge arrays
        return merge(left, right);

    }

    private static int[] merge(int[] left, int[] right) {
        int leftPoint, rightPoint, resPoint;
        leftPoint = rightPoint = resPoint = 0;
        int[] res = new int[left.length + right.length];

        //if there is elements in either the left, or the right array
        while(leftPoint < left.length || rightPoint < right.length){

            //if there exists elements in both arrays
            if(leftPoint < left.length && rightPoint < right.length) {


                //depending on which element that is greater, assert
                //the minor one to the resulting array and increment by 1
                if(left[leftPoint] < right[rightPoint]) {
                    res[resPoint++] = left[leftPoint++];
                } else {
                    res[resPoint++] = right[rightPoint++];
                }
            }
            else if(leftPoint < left.length) {
                res[resPoint++] = left[leftPoint++];
            }
            else if(rightPoint < right.length) {
                res[resPoint++] = right[rightPoint++];
            }

        }
        return res;
    }

    private static void quickSort(int[] a, int lo, int hi) {
        if((a.length > 1) && (lo < hi)) {

            int position = partition(a, lo, hi);

            quickSort(a, lo, position - 1);
            quickSort(a, position + 1, hi);
        }

    }

    // partitions sub array left <----> right so that element the last element in
    // the array is at a position where elements right of it is greater and elements at left
    private static int partition(int[] a, int lo, int hi) {

        int pivotVal = a[hi];
        int i = lo - 1;

        for(int j = lo; j < hi; j++) {
            if(a[j] < pivotVal) {
                i++;

                int val = a[i];
                a[i] = a[j];
                a[j] = val;
            }
        }

        int p = a[i + 1];
        a[i + 1] = a[hi];
        a[hi] = p;

        return i + 1;
    }

    private static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++)
            if (arr[i - 1] > arr[i]) {
                return false;
            }
        return true;
    }

}
